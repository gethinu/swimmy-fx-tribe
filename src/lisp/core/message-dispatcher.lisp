(in-package :swimmy.main)

;;; ==========================================
;;; MESSAGE DISPATCHER - Extracted from tick-handler.lisp (SRP Refactor)
;;; ==========================================

(defun internal-process-msg (msg)
  (handler-case
      (if (and (> (length msg) 0) (char= (char msg 0) #\())
          ;; S-Expression Path
          (let* ((sexp (read-from-string msg))
                 (type (cdr (assoc 'type sexp))))
            (cond
              ((member type '(backtest-result :backtest-result) :test #'eq)
               (let* ((result (cdr (assoc 'result sexp)))
                      (name (cdr (assoc 'strategy_name result)))
                      (sharpe (float (or (cdr (assoc 'sharpe result)) 0.0)))
                      (trades (or (cdr (assoc 'trades result)) 0))
                      (pnl (float (or (cdr (assoc 'pnl result)) 0.0)))
                      (win-rate (float (or (cdr (assoc 'win_rate result)) 0.0)))
                      (profit-factor (float (or (cdr (assoc 'profit_factor result)) 0.0))))
                 (swimmy.school:cache-backtest-result name 
                   (list :sharpe sharpe :trades trades :pnl pnl :win-rate win-rate :profit-factor profit-factor))
                 (push (cons name (list :sharpe sharpe :trades trades :pnl pnl :win-rate win-rate :profit-factor profit-factor))
                       *backtest-results-buffer*)
                 (when (and *expected-backtest-count* (> *expected-backtest-count* 0)
                            (>= (length *backtest-results-buffer*) *expected-backtest-count*))
                   (swimmy.core:notify-backtest-summary))
                 (when (fboundp 'swimmy.school:process-wfv-result)
                   (swimmy.school:process-wfv-result name 
                      (list :sharpe sharpe :trades trades :pnl pnl :win-rate win-rate :profit-factor profit-factor)))))
              ((member type '(cpcv-result :cpcv-result) :test #'eq)
               (let* ((result (cdr (assoc 'result sexp)))
                      (name (cdr (assoc 'strategy_name result)))
                      (median (cdr (assoc 'median_sharpe result)))
                      (paths (cdr (assoc 'path_count result)))
                      (passed (cdr (assoc 'passed_count result)))
                      (failed (cdr (assoc 'failed_count result)))
                      (pass-rate (cdr (assoc 'pass_rate result)))
                      (is-passed (cdr (assoc 'is_passed result))))
                 (format t "[L] ðŸ† CPCV Result Received for ~a: ~a~%" name (if is-passed "PASSED" "FAILED"))
                 (swimmy.core:notify-cpcv-result 
                  (list :strategy-name name :median-sharpe median :path-count paths 
                        :passed-count passed :failed-count failed :pass-rate pass-rate :is-passed is-passed))))
              (t (format t "[L] âš ï¸ Unhandled S-Exp Message Type: ~a~%" type))))
          ;; Legacy JSON Path
          (let* ((json (jsown:parse msg)) (type (jsown:val json "type")))
            (cond
              ((string= type swimmy.core:+MSG-TICK+) 
               (update-candle (jsown:val json "bid") (jsown:val json "symbol"))
               (when (fboundp 'swimmy.school:process-category-trades)
                 (swimmy.school:process-category-trades (jsown:val json "symbol") (jsown:val json "bid") (jsown:val json "ask")))
               (when (fboundp 'save-live-status) (save-live-status))
               (when (fboundp 'send-periodic-status-report)
                 (send-periodic-status-report (jsown:val json "symbol") (jsown:val json "bid")))
               (handler-case (when (fboundp 'continuous-learning-step) (continuous-learning-step)) (error () nil)))
              ((string= type swimmy.core:+MSG-HEARTBEAT+)
               (unless (numberp *last-guardian-heartbeat*) (setf *last-guardian-heartbeat* 0))
               (setf *last-guardian-heartbeat* (get-universal-time)))
              ((string= type swimmy.core:+MSG-ACCOUNT-INFO+)
               (swimmy.executor:process-account-info json))
              ((string= type swimmy.core:+MSG-HISTORY+)
               (let* ((symbol (if (jsown:keyp json "symbol") (jsown:val json "symbol") "USDJPY"))
                      (tf (if (jsown:keyp json "tf") (jsown:val json "tf") "M1"))
                      (cache-key (format nil "~a-~a" symbol tf))
                      (now (get-universal-time))
                      (last-process (gethash cache-key *history-process-cache* 0)))
                 (when (> (- now last-process) 60) 
                   (setf (gethash cache-key *history-process-cache*) now)
                   (unless (and (boundp '*candle-histories*) *candle-histories*)
                     (setf *candle-histories* (make-hash-table :test 'equal)))
                   (unless (and (boundp '*candle-histories-tf*) *candle-histories-tf*)
                     (setf *candle-histories-tf* (make-hash-table :test 'equal)))
                   (let ((bars nil))
                     (dolist (b (jsown:val json "data"))
                       (let ((c (jsown:val b "c")))
                         (push (make-candle :timestamp (jsown:val b "t") 
                                            :open c :high c :low c :close c :volume 1) bars)))
                     (unless (gethash symbol *candle-histories-tf*)
                       (setf (gethash symbol *candle-histories-tf*) (make-hash-table :test 'equal)))
                     (let ((existing (gethash tf (gethash symbol *candle-histories-tf*))))
                       (if existing
                           (setf bars (sort (remove-duplicates (append bars existing) :key #'candle-timestamp :test #'=) #'> :key #'candle-timestamp))
                           (setf bars (sort bars #'> :key #'candle-timestamp)))
                       (when (> (length bars) 50000) (setf bars (subseq bars 0 50000))))
                     (setf (gethash tf (gethash symbol *candle-histories-tf*)) bars)
                     (when (or (string= tf "M1") (string= tf "Default"))
                       (setf (gethash symbol *candle-histories*) bars)
                       (setf *candle-history* bars)
                       (let ((has-gap (swimmy.core:check-data-gap symbol bars)))
                         (when (and (fboundp 'swimmy.school:batch-backtest-knowledge) (not (and (boundp '*initial-backtest-done*) *initial-backtest-done*)) (> (length bars) 100))
                           (swimmy.school:batch-backtest-knowledge)
                           (setf *initial-backtest-done* t))))))))
              ((string= type "SYSTEM_COMMAND")
               (let ((action (jsown:val json "action")))
                 (cond
                   ((string= action "REPORT_STATUS") (swimmy.school:report-active-positions))
                   ((string= action "DAILY_REPORT") (send-daily-tribal-narrative))
                   ((string= action "BACKTEST_SUMMARY") (notify-backtest-summary))
                   ((string= action "RELOAD_CONFIG")
                    (handler-case (progn (load #P"/home/swimmy/swimmy/src/lisp/core/globals.lisp") (load #P"/home/swimmy/swimmy/src/lisp/core/config.lisp") (format t "[L] âœ… Config Reloaded!~%")) (error (e) (format t "[L] âŒ Reload Failed: ~a~%" e))))
                   ((string= action "RESET_WARRIORS")
                    (handler-case (progn (when (fboundp 'swimmy.school:debug-reset-warriors) (funcall 'swimmy.school:debug-reset-warriors)) (format t "[L] âœ… Warriors Reset Complete!~%")) (error (e) (format t "[L] âŒ Reset Warriors Failed: ~a~%" e))))
                   ((string= action "DEBUG_ENTRY")
                    (let ((target-symbol (if (jsown:keyp json "symbol") (jsown:val json "symbol") "USDJPY")))
                      (handler-case (let ((symbol target-symbol) (magic 999999) (lot 0.01)) (swimmy.engine:safe-order "BUY" symbol lot 130.00 160.00 magic) (swimmy.shell:notify-discord-symbol symbol (format nil "ðŸ§ª **DEBUG TEST ENTRY**~%Action: BUY ~a" symbol) :color 3066993)) (error (e) (format t "[L] âŒ DEBUG ENTRY Failed: ~a~%" e)))))
                   ((string= action "RESET_RISK")
                    (handler-case (progn (setf swimmy.globals::*max-drawdown* 0.0) (setf swimmy.globals::*daily-pnl* 0.0) (setf swimmy.globals::*consecutive-losses* 0) (when (boundp 'swimmy.globals::*current-equity*) (setf swimmy.globals::*peak-equity* swimmy.globals::*current-equity*)) (format t "[L] âœ… Risk State Reset!~%")) (error (e) (format t "[L] âŒ Reset Risk Failed: ~a~%" e)))))))
              ((string= type "BACKTEST_RESULT")
               (let* ((result (jsown:val json "result"))
                      (name (jsown:val result "strategy_name"))
                      (sharpe (float (or (handler-case (jsown:val result "sharpe") (error () 0.0)) 0.0)))
                      (trades (or (handler-case (jsown:val result "trades") (error () 0)) 0))
                      (pnl (float (or (handler-case (jsown:val result "pnl") (error () 0.0)) 0.0)))
                      (win-rate (float (or (handler-case (jsown:val result "win_rate") (error () 0.0)) 0.0)))
                      (profit-factor (float (or (handler-case (jsown:val result "profit_factor") (error () 0.0)) 0.0))))
                 (swimmy.school:cache-backtest-result name (list :sharpe sharpe :trades trades :pnl pnl :win-rate win-rate :profit-factor profit-factor))
                 (push (cons name (list :sharpe sharpe :trades trades :pnl pnl :win-rate win-rate :profit-factor profit-factor)) *backtest-results-buffer*)
                 (when (and *expected-backtest-count* (> *expected-backtest-count* 0) (>= (length *backtest-results-buffer*) *expected-backtest-count*)) (swimmy.core:notify-backtest-summary))
                 (when (fboundp 'swimmy.school:process-wfv-result) (swimmy.school:process-wfv-result name (list :sharpe sharpe :trades trades :pnl pnl :win-rate win-rate :profit-factor profit-factor)))
                 (let ((strat (or (find name swimmy.school::*strategy-knowledge-base* :key #'swimmy.school::strategy-name :test #'string=)
                                  (find name swimmy.globals::*evolved-strategies* :key #'swimmy.school::strategy-name :test #'string=))))
                   (when strat
                     (setf (swimmy.school::strategy-sharpe strat) sharpe)
                     (setf (swimmy.school::strategy-pf strat) profit-factor)
                     (setf (swimmy.school::strategy-win-rate strat) (/ win-rate 100.0))
                     (setf (swimmy.school::strategy-trades strat) trades)
                     (cond
                       ((< sharpe 0.1)
                        (when (fboundp 'swimmy.school::prune-to-graveyard)
                          (funcall 'swimmy.school::prune-to-graveyard strat "Sharpe < 0.1 (Phase 1 BT)")))
                       (t
                        (unless (member (swimmy.school:strategy-rank strat) '(:A :S :legend))
                          (swimmy.school:ensure-rank strat :B (format nil "Phase 1 BT Passed (S=~,2f)" sharpe)))))))))
              ((string= type "CPCV_RESULT")
               (let* ((result (jsown:val json "result"))
                      (name (jsown:val result "strategy_name"))
                      (median (float (jsown:val result "median_sharpe")))
                      (paths (jsown:val result "path_count"))
                      (passed (jsown:val result "passed_count"))
                      (failed (jsown:val result "failed_count"))
                      (pass-rate (float (jsown:val result "pass_rate")))
                      (is-passed (jsown:val result "is_passed")))
                 (format t "[L] ðŸ† CPCV Result Received (JSON) for ~a: ~a~%" name (if is-passed "PASSED" "FAILED"))
                 (swimmy.core:notify-cpcv-result 
                  (list :strategy-name name :median-sharpe median :path-count paths 
                        :passed-count passed :failed-count failed :pass-rate pass-rate :is-passed is-passed))))
              (t nil))))
    (error (e)
      (format t "[L] âš ï¸ Error processing message: ~a~%" e)
      (format t "[L] Raw Msg: ~a~%" msg)
      nil)))

(defun process-msg (msg)
  (internal-process-msg msg))
